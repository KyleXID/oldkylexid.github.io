---
layout: post
title:  "Backend에서 인증, 인가/git 프로젝트 관련"
date: 2019-04-30
categories: TIL
---

## 인증, 인가

# 인증(Authentication)
 - 유저의 identification을 확인하는 절차.

# 인가(Authorization)
 - 유저의 request를 실행할 수 있는 권한이 있는 유저인가를 확인하는 절차.

# 작동 방식
 - Access Token => 로그인 했어 라는 Token을 request의 header부분에 붙여서 보냄.
 - 서버가 Token을 response로 받음

# 유저 비밀번호 암호화 방식
 - 단방향 해쉬 함수
    - 애초에 패스워드 보안용으로 설계된 것이 아님.
    - 동일한 값은 동일하게 해쉬되서 바뀌기 때문에 해쉬값을 역 추적할 수 있다는 단점이 존재함.(rainbow table attack)
 - 보완점으로 나온 것 :  Bcrypt

# Bcrypt
 - salting
    - 소금을 뿌린다는 것처럼 추가적으로 랜덤 데이터를 더해서 해쉬값을 계산함.
 - key stretching
    - 단방향 해쉬값을 계산 한 후 그 해쉬값을 또 해쉬하는 형식으로 계속 반복함.

# Web Tokens
 - 웹상에서 사용할 수 있는 토큰
    - 웹상인데 제이슨에서 사용할수있는 토큰 : jwt(json web token)
 - 웹 토큰을 사용하는 이유?
    1. 속도 문제
    2. 쿠키에 저장해야되는데, 쿠키에 아이디 비밀번호 저장하는 것과, 토큰을 저장하는 것과는 큰 차이가 있음.
 - 웹토큰은 . 로 나뉘어져있는데, 첫번째, 두번째 부분은 코드화로 아무나 복호화 할 수 있음. 암호화가 아니다.
 - 마지막 세번째 부분 암호화. 서버에서 복호화해서 내가 만든것인지 확인하는 용도이다.

# 데코레이터를 사용하는 이유
 - 엔드포인트가 200개가 될 경우 하나하나 코드를 넣어주기도 힘들고, 코드 중복을 없앨 수 있다.
 - 강제성을 부여할 수 있다. (강제성 부여 : 로그인 상태로 수행되어야 하는 기능들은 로그인 하지 않으면 접근하지 못하도록 한다.)
 - 로그인 데코레이터 구성
    0. wrapper는 `self, request, *args, **kwargs`를 input
    1. Front에서 해당 유저의 웹 토큰을 받음.
    2. 토큰이 존재하면 진행, 존재하지 않는다면 status 리턴
    3. 웹 토큰을 decode한 후 그 값으로 해당 유저의 정보에 접근하여 불러옴.
    4. 그 정보를 이용하여 감싸는 함수 실행.
    4. 에러메세지는 try, except를 활용하여 체크.

<br/>

## git 프로젝트 branch관련
 - branch를 따고나서 작업을 하는 도중, master가 업데이트 되더라도 다시 갱신 할 필요 없이, push해서 merge해주면 된다.
 - 새로 branch를 따려고 할 때는 pull을 통해서 프로젝트를 업데이트 한 후에 시작한다.
 - commit은 해당 사항을 진행하는 동안 꾸준히 할 수 있지만, 만약 상대방이 3일동안 1개 commit하고 나는 2주동안 11개의 commit을 한다고 가정 했을때, 상대방의 commit과 나의 commit이 서로 뒤엉켜서 후에 롤백을 하는데 혼선이 될 수 있다.
    - 이는 commit이 시간순으로 모두 합쳐져 정렬되기 때문에 발생하는 문제이다.
 - 이를 피하기 위해 보통 commit을 여러개 한 뒤, 마지막 push할 때는 squash로 commit을 압축하여 1개로 만들어서 push하게 된다.


